import { BusinessContext, Deal, ActionItem, Lead } from "@/types"

export interface AIInsight {
  id: string
  type: "warning" | "success" | "info" | "opportunity"
  icon: string
  title: string
  description: string
  priority: "high" | "medium" | "low"
  actionable?: boolean
  suggestedAction?: {
    type: "call" | "email" | "meeting"
    target: string
    description: string
  }
}

export interface SuggestedAction {
  id: string
  title: string
  description: string
  priority: "high" | "medium" | "low"
  dueDate?: Date
  relatedTo?: {
    type: "deal" | "lead"
    id: string
    name: string
  }
  completed: boolean
  autoGenerated: boolean
}

export class AIInsightsEngine {
  // G√©n√©rer des insights bas√©s sur les donn√©es business
  static generateInsights(context: BusinessContext): AIInsight[] {
    const insights: AIInsight[] = []

    // Analyser les deals stagnants
    const stagnantDeals = this.findStagnantDeals(context.topDeals)
    stagnantDeals.forEach(deal => {
      insights.push({
        id: `stagnant-${deal.id}`,
        type: "warning",
        icon: "‚ö†Ô∏è",
        title: `Le deal "${deal.company}" stagne`,
        description: `Aucune activit√© depuis ${this.getDaysSinceActivity(deal.lastActivity)} jours. Probabilit√© de perte √©lev√©e.`,
        priority: "high",
        actionable: true,
        suggestedAction: {
          type: "call",
          target: deal.company,
          description: `Relancer ${deal.contact} (${deal.company})`
        }
      })
    })

    // Identifier les leads chauds
    const hotLeads = context.hotLeads.filter(lead => lead.score >= 80)
    if (hotLeads.length > 0) {
      insights.push({
        id: "hot-leads",
        type: "opportunity",
        icon: "üéØ",
        title: `${hotLeads.length} lead${hotLeads.length > 1 ? 's' : ''} chaud${hotLeads.length > 1 ? 's' : ''} √† contacter`,
        description: `Leads avec un score > 80: ${hotLeads.map(l => l.company).join(", ")}`,
        priority: "high",
        actionable: true
      })
    }

    // Calculer la probabilit√© de closing du mois
    const closingProbability = this.calculateMonthClosingProbability(context.topDeals)
    insights.push({
      id: "closing-probability",
      type: closingProbability > 60 ? "success" : "info",
      icon: closingProbability > 60 ? "üéâ" : "üí∞",
      title: `Probabilit√© de closing ce mois: ${closingProbability}%`,
      description: this.getClosingDescription(closingProbability, context.topDeals),
      priority: "medium",
      actionable: false
    })

    // Deals en phase de n√©gociation/closing
    const nearClosingDeals = context.topDeals.filter(
      d => (d.stage === "N√©gociation" || d.stage === "Closing") && d.probability >= 60
    )
    if (nearClosingDeals.length > 0) {
      insights.push({
        id: "near-closing",
        type: "success",
        icon: "üî•",
        title: `${nearClosingDeals.length} deal${nearClosingDeals.length > 1 ? 's' : ''} proche${nearClosingDeals.length > 1 ? 's' : ''} du closing`,
        description: `Concentrez-vous sur: ${nearClosingDeals.map(d => d.company).slice(0, 3).join(", ")}`,
        priority: "high",
        actionable: true
      })
    }

    // Pipeline √©quilibr√© ou non
    const pipelineBalance = this.analyzePipelineBalance(context.topDeals)
    insights.push({
      id: "pipeline-balance",
      type: pipelineBalance.balanced ? "success" : "warning",
      icon: pipelineBalance.balanced ? "‚úÖ" : "üìä",
      title: pipelineBalance.title,
      description: pipelineBalance.description,
      priority: pipelineBalance.balanced ? "low" : "medium",
      actionable: !pipelineBalance.balanced
    })

    // Actions en retard
    const overdueActions = context.actionItems.filter(
      a => a.dueDate && new Date(a.dueDate) < new Date() && !a.completed
    )
    if (overdueActions.length > 0) {
      insights.push({
        id: "overdue-actions",
        type: "warning",
        icon: "‚è∞",
        title: `${overdueActions.length} action${overdueActions.length > 1 ? 's' : ''} en retard`,
        description: `Vous avez des actions non compl√©t√©es d√©passant leur √©ch√©ance`,
        priority: "high",
        actionable: true
      })
    }

    return insights.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 }
      return priorityOrder[b.priority] - priorityOrder[a.priority]
    })
  }

  // G√©n√©rer des actions sugg√©r√©es
  static generateSuggestedActions(context: BusinessContext): SuggestedAction[] {
    const suggestions: SuggestedAction[] = []

    // Actions pour deals stagnants
    const stagnantDeals = this.findStagnantDeals(context.topDeals)
    stagnantDeals.forEach(deal => {
      const daysSince = this.getDaysSinceActivity(deal.lastActivity)
      suggestions.push({
        id: `action-${deal.id}`,
        title: `Relancer ${deal.contact} (${deal.company})`,
        description: `Aucune activit√© depuis ${daysSince} jours. Risque de perte du deal de ${deal.value.toLocaleString('fr-FR')} ‚Ç¨`,
        priority: "high",
        dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // Demain
        relatedTo: {
          type: "deal",
          id: deal.id,
          name: deal.company
        },
        completed: false,
        autoGenerated: true
      })
    })

    // Actions pour leads chauds
    const hotLeads = context.hotLeads.filter(lead => lead.score >= 80 && lead.status === "Nouveau")
    hotLeads.slice(0, 3).forEach(lead => {
      suggestions.push({
        id: `action-lead-${lead.id}`,
        title: `Contacter ${lead.contact} (${lead.company})`,
        description: `Lead chaud avec un score de ${lead.score}. Priorit√© √©lev√©e.`,
        priority: "high",
        dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
        relatedTo: {
          type: "lead",
          id: lead.id,
          name: lead.company
        },
        completed: false,
        autoGenerated: true
      })
    })

    // Actions pour deals en proposition
    const propositionDeals = context.topDeals.filter(d => d.stage === "Proposition")
    propositionDeals.forEach(deal => {
      suggestions.push({
        id: `action-proposal-${deal.id}`,
        title: `Suivre la proposition pour ${deal.company}`,
        description: `Deal en phase proposition. Faire un point sur l'avancement.`,
        priority: "medium",
        dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // Dans 3 jours
        relatedTo: {
          type: "deal",
          id: deal.id,
          name: deal.company
        },
        completed: false,
        autoGenerated: true
      })
    })

    return suggestions.slice(0, 5) // Limiter √† 5 suggestions max
  }

  // Analyser un deal sp√©cifique
  static analyzeDeal(deal: Deal, allDeals: Deal[]): {
    closingProbability: number
    estimatedDays: number
    riskLevel: "low" | "medium" | "high"
    recommendation: string
    similarDeals: Deal[]
  } {
    const daysSinceActivity = this.getDaysSinceActivity(deal.lastActivity)

    // Calculer le risque
    let riskLevel: "low" | "medium" | "high" = "low"
    if (daysSinceActivity > 14) riskLevel = "high"
    else if (daysSinceActivity > 7) riskLevel = "medium"

    // Estimer les jours avant closing
    const stageMultiplier = {
      "Prospection": 45,
      "Qualification": 35,
      "Proposition": 25,
      "N√©gociation": 15,
      "Closing": 7,
      "Gagn√©": 0,
      "Perdu": 0
    }
    const estimatedDays = stageMultiplier[deal.stage]

    // Ajuster la probabilit√©
    let adjustedProbability = deal.probability
    if (daysSinceActivity > 10) adjustedProbability -= 15
    if (deal.stage === "N√©gociation" || deal.stage === "Closing") adjustedProbability += 10

    // G√©n√©rer une recommandation
    let recommendation = ""
    if (riskLevel === "high") {
      recommendation = `‚ö†Ô∏è Action urgente requise ! Relancez ${deal.contact} aujourd'hui. Le deal risque d'√™tre perdu.`
    } else if (deal.stage === "Proposition") {
      recommendation = `Envoyez une proposition personnalis√©e avant vendredi pour maintenir l'engagement.`
    } else if (deal.stage === "N√©gociation") {
      recommendation = `Pr√©parez votre strat√©gie de n√©gociation. Identifiez les objections possibles.`
    } else {
      recommendation = `Maintenez le contact r√©gulier. Prochaine action dans les 3-5 jours.`
    }

    // Trouver des deals similaires
    const similarDeals = allDeals.filter(
      d => d.id !== deal.id &&
      d.stage === deal.stage &&
      Math.abs(d.value - deal.value) / deal.value < 0.5
    ).slice(0, 2)

    return {
      closingProbability: Math.max(0, Math.min(100, adjustedProbability)),
      estimatedDays,
      riskLevel,
      recommendation,
      similarDeals
    }
  }

  // Utilitaires priv√©s
  private static findStagnantDeals(deals: Deal[]): Deal[] {
    return deals.filter(deal => {
      const daysSince = this.getDaysSinceActivity(deal.lastActivity)
      return daysSince > 10 && deal.stage !== "Gagn√©" && deal.stage !== "Perdu"
    })
  }

  private static getDaysSinceActivity(lastActivity: Date): number {
    const now = new Date()
    const last = new Date(lastActivity)
    const diff = now.getTime() - last.getTime()
    return Math.floor(diff / (1000 * 60 * 60 * 24))
  }

  private static calculateMonthClosingProbability(deals: Deal[]): number {
    const activeDeals = deals.filter(d => d.stage !== "Gagn√©" && d.stage !== "Perdu")
    if (activeDeals.length === 0) return 0

    const weightedProb = activeDeals.reduce((sum, deal) => {
      const stageWeight = {
        "Prospection": 0.2,
        "Qualification": 0.4,
        "Proposition": 0.6,
        "N√©gociation": 0.8,
        "Closing": 0.9
      }
      return sum + (deal.probability * (stageWeight[deal.stage as keyof typeof stageWeight] || 0.5))
    }, 0)

    return Math.round(weightedProb / activeDeals.length)
  }

  private static getClosingDescription(probability: number, deals: Deal[]): string {
    const nearClosingDeals = deals.filter(d =>
      (d.stage === "N√©gociation" || d.stage === "Closing") &&
      d.probability >= 60
    )

    if (probability > 70) {
      return `Excellent ! Vous avez ${nearClosingDeals.length} deal(s) en bonne voie. Continuez sur cette lanc√©e.`
    } else if (probability > 50) {
      return `Bon potentiel. Concentrez-vous sur les deals en phase de closing.`
    } else {
      return `Potentiel moyen. Augmentez vos efforts de prospection et qualification.`
    }
  }

  private static analyzePipelineBalance(deals: Deal[]): {
    balanced: boolean
    title: string
    description: string
  } {
    const activeDeals = deals.filter(d => d.stage !== "Gagn√©" && d.stage !== "Perdu")
    const stages = ["Prospection", "Qualification", "Proposition", "N√©gociation", "Closing"]

    const distribution = stages.map(stage => ({
      stage,
      count: activeDeals.filter(d => d.stage === stage).length
    }))

    const avgPerStage = activeDeals.length / stages.length
    const isBalanced = distribution.every(d =>
      Math.abs(d.count - avgPerStage) <= avgPerStage * 0.5
    )

    const emptyStages = distribution.filter(d => d.count === 0)

    if (isBalanced) {
      return {
        balanced: true,
        title: "Pipeline bien √©quilibr√©",
        description: "Votre pipeline est harmonieusement r√©parti sur toutes les phases. Continuez !"
      }
    } else if (emptyStages.length > 0) {
      return {
        balanced: false,
        title: "Pipeline d√©s√©quilibr√©",
        description: `Attention: aucun deal en phase ${emptyStages[0].stage}. Augmentez vos efforts de prospection.`
      }
    } else {
      return {
        balanced: false,
        title: "Pipeline √† optimiser",
        description: "Certaines phases du pipeline n√©cessitent plus d'attention."
      }
    }
  }
}
