import { BusinessContext, Deal, ActionItem } from "@/types"
import { geminiClientService } from "@/lib/gemini-client"

export interface AIInsight {
  id: string
  type: "warning" | "success" | "info" | "opportunity"
  icon: string
  title: string
  description: string
  priority: "high" | "medium" | "low"
  actionable?: boolean
  suggestedAction?: {
    type: "call" | "email" | "meeting"
    target: string
    description: string
  }
}

export interface SuggestedAction {
  id: string
  title: string
  description: string
  priority: "high" | "medium" | "low"
  dueDate?: Date
  relatedTo?: {
    type: "deal" | "lead"
    id: string
    name: string
  }
  completed: boolean
  autoGenerated: boolean
}

export class AIInsightsGeminiEngine {
  // Générer des insights propulsés par Gemini
  static async generateInsights(context: BusinessContext): Promise<AIInsight[]> {
    try {
      const prompt = `Tu es un analyste commercial expert. Analyse ce contexte business et génère 5-7 insights actionnables.

CONTEXTE BUSINESS:
- CA actuel: ${context.metrics.revenue.toLocaleString('fr-FR')} € (${context.metrics.revenueGrowth > 0 ? '+' : ''}${context.metrics.revenueGrowth}%)
- Leads: ${context.metrics.leads} (${context.metrics.leadsGrowth > 0 ? '+' : ''}${context.metrics.leadsGrowth}%)
- Taux de conversion: ${context.metrics.conversionRate}%
- Pipeline: ${context.metrics.pipelineValue.toLocaleString('fr-FR')} €
- Cycle de vente moyen: ${context.metrics.salesCycle} jours

DEALS ACTIFS (${context.topDeals.length}):
${context.topDeals.map(d => `- ${d.company}: ${d.value.toLocaleString('fr-FR')} € (${d.stage}, ${d.probability}%, dernière activité: ${this.getDaysSinceActivity(d.lastActivity)}j)`).join('\n')}

LEADS CHAUDS (${context.hotLeads.length}):
${context.hotLeads.slice(0, 5).map(l => `- ${l.company} (score: ${l.score}, statut: ${l.status})`).join('\n')}

ACTIONS (${context.actionItems.length}):
- Complétées: ${context.actionItems.filter(a => a.completed).length}
- En cours: ${context.actionItems.filter(a => !a.completed).length}
- En retard: ${context.actionItems.filter(a => a.dueDate && new Date(a.dueDate) < new Date() && !a.completed).length}

INSTRUCTIONS:
Génère un tableau JSON d'insights avec exactement cette structure:
[
  {
    "type": "warning|success|info|opportunity",
    "icon": "emoji pertinent",
    "title": "titre court et percutant",
    "description": "description détaillée et actionnable (1-2 phrases)",
    "priority": "high|medium|low",
    "actionable": true|false
  }
]

FOCUS SUR:
1. Deals stagnants (>10j sans activité)
2. Leads chauds non contactés
3. Opportunités de closing (deals en négociation/closing)
4. Déséquilibres du pipeline
5. Actions en retard
6. Tendances CA/conversion
7. Recommandations stratégiques

IMPORTANT:
- Sois spécifique avec noms d'entreprises
- Priorise par impact business
- Fournis des insights actionnables
- Maximum 7 insights
- Retourne UNIQUEMENT le JSON valide, rien d'autre`

      const response = await geminiClientService.generateContent(prompt)

      // Parser la réponse JSON avec nettoyage robuste
      let cleanedResponse = response.trim()

      // Retirer les marqueurs de code markdown
      cleanedResponse = cleanedResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '')

      // Extraire le JSON entre crochets
      const jsonMatch = cleanedResponse.match(/\[[\s\S]*?\](?=\s*$|$)/)
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0]
      }

      // Nettoyer les caractères problématiques
      cleanedResponse = cleanedResponse
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') // Caractères de contrôle
        .replace(/\n/g, ' ') // Remplacer les retours à la ligne par des espaces
        .replace(/\r/g, '') // Retirer les retours chariot
        .replace(/\t/g, ' ') // Remplacer les tabs par des espaces
        .replace(/\s+/g, ' ') // Normaliser les espaces multiples
        .trim()

      try {
        const parsedInsights = JSON.parse(cleanedResponse)
        if (!Array.isArray(parsedInsights)) {
          throw new Error("La réponse n'est pas un tableau")
        }
        return parsedInsights.map((insight: any, index: number) => ({
          id: `gemini-insight-${index}`,
          ...insight
        }))
      } catch (parseError) {
        console.error("Erreur parsing JSON insights:", parseError)
        console.error("Réponse nettoyée:", cleanedResponse.substring(0, 500))
        throw parseError
      }

    } catch (error) {
      console.error("Erreur génération insights Gemini:", error)
      // Fallback sur les insights par règles
      return this.generateFallbackInsights(context)
    }
  }

  // Générer des actions suggérées avec Gemini
  static async generateSuggestedActions(context: BusinessContext): Promise<SuggestedAction[]> {
    try {
      const prompt = `Tu es un assistant commercial. Génère 3-5 actions concrètes à réaliser AUJOURD'HUI.

CONTEXTE BUSINESS:
${context.topDeals.slice(0, 5).map(d => `- ${d.company}: ${d.value.toLocaleString('fr-FR')} € (${d.stage}, activité: ${this.getDaysSinceActivity(d.lastActivity)}j)`).join('\n')}

LEADS CHAUDS:
${context.hotLeads.slice(0, 3).map(l => `- ${l.company} (score: ${l.score}, statut: ${l.status})`).join('\n')}

INSTRUCTIONS:
Génère un tableau JSON d'actions avec exactement cette structure:
[
  {
    "title": "titre de l'action (court)",
    "description": "description détaillée de pourquoi c'est important",
    "priority": "high|medium|low",
    "companyName": "nom de l'entreprise concernée",
    "companyId": "id du deal ou lead concerné (si applicable)",
    "relatedType": "deal|lead",
    "dueDays": 0-3 (nombre de jours avant échéance, 0=aujourd'hui, 1=demain, etc.)
  }
]

FOCUS:
1. Deals stagnants à relancer EN PRIORITÉ
2. Leads chauds à contacter AUJOURD'HUI
3. Deals en proposition à suivre
4. Opportunités de closing à pousser

Maximum 5 actions, priorisées par impact business.
Retourne UNIQUEMENT le JSON valide.`

      const response = await geminiClientService.generateContent(prompt)

      // Parser la réponse JSON avec nettoyage robuste
      let cleanedResponse = response.trim()
      cleanedResponse = cleanedResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '')

      // Extraire le JSON entre crochets
      const jsonMatch = cleanedResponse.match(/\[[\s\S]*?\](?=\s*$|$)/)
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0]
      }

      // Nettoyer les caractères problématiques
      cleanedResponse = cleanedResponse
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '')
        .replace(/\n/g, ' ')
        .replace(/\r/g, '')
        .replace(/\t/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()

      try {
        const parsedActions = JSON.parse(cleanedResponse)
        if (!Array.isArray(parsedActions)) {
          throw new Error("La réponse n'est pas un tableau")
        }
        return parsedActions.map((action: any, index: number) => ({
          id: `gemini-action-${Date.now()}-${index}`,
          title: action.title,
          description: action.description,
          priority: action.priority,
          dueDate: new Date(Date.now() + (action.dueDays || 1) * 24 * 60 * 60 * 1000),
          relatedTo: action.companyName ? {
            type: action.relatedType || "deal",
            id: action.companyId || `unknown-${index}`,
            name: action.companyName
          } : undefined,
          completed: false,
          autoGenerated: true
        }))
      } catch (parseError) {
        console.error("Erreur parsing JSON actions:", parseError)
        console.error("Réponse nettoyée:", cleanedResponse.substring(0, 500))
        throw parseError
      }

    } catch (error) {
      console.error("Erreur génération actions Gemini:", error)
      // Fallback sur les actions par règles
      return this.generateFallbackActions(context)
    }
  }

  // Analyser un deal avec Gemini
  static async analyzeDeal(deal: Deal, allDeals: Deal[]): Promise<{
    closingProbability: number
    estimatedDays: number
    riskLevel: "low" | "medium" | "high"
    recommendation: string
    keyInsights: string[]
  }> {
    try {
      const daysSince = this.getDaysSinceActivity(deal.lastActivity)

      const prompt = `Tu es un analyste commercial expert. Analyse ce deal et fournis des insights précis.

DEAL À ANALYSER:
- Entreprise: ${deal.company}
- Contact: ${deal.contact}
- Valeur: ${deal.value.toLocaleString('fr-FR')} €
- Phase: ${deal.stage}
- Probabilité actuelle: ${deal.probability}%
- Dernière activité: ${daysSince} jours
${deal.nextStep ? `- Prochaine étape: ${deal.nextStep}` : ''}

CONTEXTE:
- ${allDeals.length} deals au total
- Deals similaires en phase ${deal.stage}: ${allDeals.filter(d => d.stage === deal.stage).length}

INSTRUCTIONS:
Génère un JSON avec exactement cette structure:
{
  "closingProbability": <nombre entre 0 et 100, ajusté selon activité et phase>,
  "estimatedDays": <estimation jours avant closing>,
  "riskLevel": "low|medium|high",
  "recommendation": "recommandation stratégique en 1-2 phrases",
  "keyInsights": ["insight 1", "insight 2", "insight 3"]
}

IMPORTANT:
- Sois réaliste sur la probabilité (pénalise si inactivité)
- Fournis une recommandation actionnable
- 3 insights clés maximum
- Retourne UNIQUEMENT le JSON valide`

      const response = await geminiClientService.generateContent(prompt)

      // Parser la réponse JSON avec nettoyage robuste
      let cleanedResponse = response.trim()
      cleanedResponse = cleanedResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '')

      // Extraire le JSON entre accolades
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*?\}(?=\s*$|$)/)
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0]
      }

      // Nettoyer les caractères problématiques
      cleanedResponse = cleanedResponse
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '')
        .replace(/\n/g, ' ')
        .replace(/\r/g, '')
        .replace(/\t/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()

      try {
        return JSON.parse(cleanedResponse)
      } catch (parseError) {
        console.error("Erreur parsing JSON deal:", parseError)
        console.error("Réponse nettoyée:", cleanedResponse.substring(0, 500))
        throw parseError
      }
    } catch (error) {
      console.error("Erreur analyse deal Gemini:", error)
      // Fallback sur analyse par règles
      return this.analyzeDealFallback(deal, allDeals)
    }
  }

  // Fallback: insights par règles (comme avant)
  private static generateFallbackInsights(context: BusinessContext): AIInsight[] {
    const insights: AIInsight[] = []

    const stagnantDeals = context.topDeals.filter(d =>
      this.getDaysSinceActivity(d.lastActivity) > 10 && d.stage !== "Gagné" && d.stage !== "Perdu"
    )

    if (stagnantDeals.length > 0) {
      insights.push({
        id: "stagnant-fallback",
        type: "warning",
        icon: "⚠️",
        title: `${stagnantDeals.length} deal(s) stagnant(s)`,
        description: "Plusieurs opportunités sans activité récente. Action requise.",
        priority: "high",
        actionable: true
      })
    }

    return insights
  }

  // Fallback: actions par règles
  private static generateFallbackActions(context: BusinessContext): SuggestedAction[] {
    const suggestions: SuggestedAction[] = []

    context.topDeals.slice(0, 3).forEach((deal, index) => {
      if (this.getDaysSinceActivity(deal.lastActivity) > 7) {
        suggestions.push({
          id: `fallback-${index}`,
          title: `Relancer ${deal.company}`,
          description: `Aucune activité depuis ${this.getDaysSinceActivity(deal.lastActivity)} jours`,
          priority: "high",
          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
          relatedTo: { type: "deal", id: deal.id, name: deal.company },
          completed: false,
          autoGenerated: true
        })
      }
    })

    return suggestions
  }

  // Fallback: analyse deal par règles
  private static analyzeDealFallback(deal: Deal, allDeals: Deal[]): {
    closingProbability: number
    estimatedDays: number
    riskLevel: "low" | "medium" | "high"
    recommendation: string
    keyInsights: string[]
  } {
    const daysSince = this.getDaysSinceActivity(deal.lastActivity)

    let risk: "low" | "medium" | "high" = "low"
    if (daysSince > 14) risk = "high"
    else if (daysSince > 7) risk = "medium"

    const stageDays = {
      "Prospection": 45, "Qualification": 35, "Proposition": 25,
      "Négociation": 15, "Closing": 7, "Gagné": 0, "Perdu": 0
    }

    let adjustedProb = deal.probability
    if (daysSince > 10) adjustedProb -= 15

    return {
      closingProbability: Math.max(0, Math.min(100, adjustedProb)),
      estimatedDays: stageDays[deal.stage],
      riskLevel: risk,
      recommendation: risk === "high"
        ? `Action urgente requise ! Relancez ${deal.contact} aujourd'hui.`
        : "Maintenez le contact régulier.",
      keyInsights: [
        `Deal en phase ${deal.stage}`,
        `${daysSince} jours depuis dernière activité`,
        `Valeur: ${deal.value.toLocaleString('fr-FR')} €`
      ]
    }
  }

  // Utilitaire
  private static getDaysSinceActivity(lastActivity: Date): number {
    return Math.floor((new Date().getTime() - new Date(lastActivity).getTime()) / (1000 * 60 * 60 * 24))
  }
}
